/* PWM.c - Updated PWM Driver Implementation */
#include "PWM.h"

static uint32 g_pwmLoad = 0;

void PWM_Init(void)
{
    SYSCTL_RCC_R |= (1 << 22);
    SYSCTL_RCGCPWM_R |= (1 << 0) | (1 << 1);

    GPIO_PORTB_AFSEL_R |= (1 << 4) | (1 << 6);
    GPIO_PORTB_PCTL_R &= ~0x0F0F0000;
    GPIO_PORTB_PCTL_R |= (4 << 16) | (4 << 24);
    GPIO_PORTB_DEN_R |= (1 << 4) | (1 << 6);

    GPIO_PORTA_AFSEL_R |= (1 << 6) | (1 << 7);
    GPIO_PORTA_PCTL_R &= ~0xFF000000;
    GPIO_PORTA_PCTL_R |= (5 << 24) | (5 << 28);
    GPIO_PORTA_DEN_R |= (1 << 6) | (1 << 7);

    SYSCTL_RCC_R |= (1 << 20);

    uint32 pwmClock = 16000000 / 64;
    g_pwmLoad = (pwmClock / PWM_FREQUENCY) - 1;

    PWM0_0_CTL_R = 0;
    PWM0_0_LOAD_R = g_pwmLoad;
    PWM0_0_CMPA_R = g_pwmLoad;
    PWM0_0_GENA_R = 0x00000084;
    PWM0_0_CTL_R |= 0x01;
    PWM0_ENABLE_R |= (1 << 0);

    PWM0_1_CTL_R = 0;
    PWM0_1_LOAD_R = g_pwmLoad;
    PWM0_1_CMPA_R = g_pwmLoad;
    PWM0_1_GENA_R = 0x00000084;
    PWM0_1_CTL_R |= 0x01;
    PWM0_ENABLE_R |= (1 << 2);
}

void PWM_SetDuty(uint8 channel, uint8 duty_percent)
{
    if (duty_percent > 100) duty_percent = 100;
    uint32 cmp_value = g_pwmLoad - (((g_pwmLoad + 1) * duty_percent) / 100);
    switch(channel)
    {
        case PWM_CHANNEL_0: PWM0_0_CMPA_R = cmp_value; break;
        case PWM_CHANNEL_1: PWM0_1_CMPA_R = cmp_value; break;
        case PWM_CHANNEL_2: PWM1_1_CMPA_R = cmp_value; break;
        case PWM_CHANNEL_3: PWM1_1_CMPB_R = cmp_value; break;
        default: break;
    }
}

uint32 PWM_GetLoad(void)
{
    return g_pwmLoad;
}
